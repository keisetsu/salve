<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: name_resolver.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/mangalam.css">
</head>

<body>


<div id="main">

    <h1 class="page-title">Source: name_resolver.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * @module name_resolver
 * @desc Implements a name resolver for handling namespace changes in XML.
 * @author Louis-Dominique Dubeau
 * @license MPL 2.0
 * @copyright 2013 Mangalam Research Center for Buddhist Languages
 */
define(/** @lends module:name_resolver */function (require, exports, module) {
"use strict";

var validate = require("./validate");

var XML1_NAMESPACE = "http://www.w3.org/XML/1998/namespace";


/**
 * @classdesc A name resolver for handling namespace changes in
 * XML. This name resolver maintains mappings from namespace prefix to
 * namespace URI.
 *
 * @constructor
 */
function NameResolver() {
    this._context_stack = [];

    // Create a default context.
    this.enterContext();

    // Mandated by XML 1.x which is the only XML which exists now.
    this.definePrefix("xml", XML1_NAMESPACE);
}

/**
 * Makes a deep copy.
 *
 * @returns {module:name_resolver~NameResolver} A deep copy of the
 * resolver.
 */
NameResolver.prototype.clone = function() {
    var ret = new NameResolver();
    ret._context_stack = this._context_stack.slice();
    return ret;
};

/**
 * Defines a (prefix, URI) mapping.
 *
 * @param {string} prefix The namespace prefix to associate with the URI.
 * @param {string} uri The namespace URI associated with the prefix.
 */
NameResolver.prototype.definePrefix = function (prefix, uri) {
    this._context_stack[0].forward[prefix] = uri;

    var prefixes = this._context_stack[0].backwards[uri];
    if (prefixes === undefined)
        prefixes = this._context_stack[0].backwards[uri] = [];

    // This ensure that the default namespace is given priority
    // when unresolving names.
    if (prefix === "")
        prefixes.unshift("");
    else
        prefixes.push(prefix);
};

/**
 * &lt;p>This method is called to indicate the start of a new
 * context. Contexts enable this class to support namespace
 * redeclarations. In XML, each start tag can potentially redefine a
 * prefix that was already defined by an ancestor. When using this
 * class, such redefinition must appear in a new context, otherwise it
 * would merely overwrite the old definition.&lt;/p>
 *
 * &lt;p>At creation, a &lt;code>NameResolver&lt;/code> has a default context
 * already created. There is no need to create it and it is not
 * possible to leave it.&lt;/p>
 */
NameResolver.prototype.enterContext = function () {
    this._context_stack.unshift(Object.create(null));
    this._context_stack[0].forward = Object.create(null);
    this._context_stack[0].backwards = Object.create(null);
};

/**
 * This method is called to indicate the end of a context. Whatever
 * context was in effect when the current context ends become
 * effective.
 *
 * @throws {Error} If this method is called when there is no context
 * created by {@link module:name_resolver~NameResolver.enterContext
 * enterContext}.
 */
NameResolver.prototype.leaveContext = function () {
    if (this._context_stack.length > 1)
        this._context_stack.shift();
    else
        throw new Error("trying to leave the default context");
};

/**
 * Resolves a qualified name to an expanded name. A qualified name is
 * an XML name optionally prefixed by a namespace prefix. For
 * instance, in &lt;code>&lt;html xml:lang="en">&lt;/code>, "html" is a name
 * without a prefix, and "xml:lang" is a name with the "xml"
 * prefix. An expanded name is a (URI, name) pair.
 *
 * @param {string} name The name to resolve.
 * @param {boolean} attribute Whether this name appears as an attribute.
 * @throws {Error} If the name is malformed. For instance, a name with
 * two colons would be malformed.
 * @returns {module:validate~EName|undefined} The expanded name, or
 * &lt;code>undefined&lt;/code> if the name cannot be resolved.
 */
NameResolver.prototype.resolveName = function (name, attribute) {
    if (attribute === undefined)
        attribute = false;

    var parts = name.split(":");

    if (parts.length == 1) { // If there is no prefix
        if (attribute) // Attribute in undefined namespace
            return new validate.EName("", name);

        // We are searching for the default namespace currently in
        // effect.
        parts = [ "", name ];
    }

    if (parts.length > 2)
        throw new Error("invalid name passed to resolveName");

    // Search through the contexts
    var uri;
    for(var c_ix = 0, ctx;
        (uri === undefined) &&
        (ctx = this._context_stack[c_ix]) !== undefined; ++c_ix)
        uri = ctx.forward[parts[0]];

    if (uri === undefined)
        return (parts[0] === "") ? new validate.EName("", parts[1]): undefined;

    return new validate.EName(uri, parts[1]);
};

/**
 * &lt;p>Unresolves an expanded name to a qualified name. An expanded name
 * is a (URI, name) pair. Note that if we execute:
 *
 * &lt;pre>
 *   var name_resolver = new NameResolver();
 *   var ename = name_resolver.resolveName(qname);
 *   var qname2 = name_resolver.unresolveName(ename.ns, ename.name);
 * &lt;/pre>
 *
 * then &lt;code>qname === qname2&lt;/code> is not necessarily true. This
 * would happen if two prefixes map to the same URI. In such case the
 * prefix provided in the return value is arbitrarily chosen.&lt;/p>
 *
 * @param {string} uri The URI part of the expanded name. An empty
 * string is valid, and basically means "no namespace". This occurrs
 * for unprefixed attributes but could also happen if the default
 * namespace is undeclared.
 * @param {string} name The name part.
 * @returns {string|undefined} The qualified name that corresponds to
 * the expanded name, or &lt;code>undefined&lt;/code> if it cannot be resolved.
 */
NameResolver.prototype.unresolveName = function (uri, name) {
    if (uri === "")
        return name;

    // Search through the contexts
    var prefixes;
    for(var c_ix = 0, ctx;
        (prefixes === undefined) &&
        (ctx = this._context_stack[c_ix]) !== undefined; ++c_ix)
        prefixes = ctx.backwards[uri];

    if (prefixes === undefined)
        return undefined;

    var pre = prefixes[0];

    return (pre !== "") ? (pre + ":" + name) : name;

};

/**
 * Returns a prefix that, in the current context, is mapped to the URI
 * specified. Note that this function will return the first prefix
 * that satisfies the requirement, starting from the innermost
 * context.
 *
 * @param {string} uri A URI for which to get a prefix.
 * @returns {string|undefined} A prefix that maps to this
 * URI. Undefined if there is no prefix available.
 */
NameResolver.prototype.prefixFromURI = function (uri) {
    var prefixes;
    for(var c_ix = 0, ctx;
        (prefixes === undefined) &&
        (ctx = this._context_stack[c_ix]) !== undefined; ++c_ix)
        prefixes = ctx.backwards[uri];

    if (prefixes === undefined)
        return undefined;

    var pre = prefixes[0];
    return pre;
};


exports.NameResolver = NameResolver;
exports.XML1_NAMESPACE = XML1_NAMESPACE;

});

// LocalWords:  namespace unresolving MPL xml resolveName Dubeau URI
// LocalWords:  Mangalam LocalWords NameResolver lt html lang ename
// LocalWords:  qname redeclarations Unresolves
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-formats.html">formats</a></li><li><a href="module-hashstructs.html">hashstructs</a></li><li><a href="module-name_resolver.html">name_resolver</a></li><li><a href="module-oop.html">oop</a></li><li><a href="module-patterns.html">patterns</a></li><li><a href="module-set.html">set</a></li><li><a href="module-util.html">util</a></li><li><a href="module-validate.html">validate</a></li></ul><h3>Classes</h3><ul><li><a href="module-formats-V1JSONWalker.html">formats~V1JSONWalker</a></li><li><a href="module-hashstructs-HashBase.html">hashstructs~HashBase</a></li><li><a href="module-hashstructs-HashMap.html">hashstructs~HashMap</a></li><li><a href="module-hashstructs-HashSet.html">hashstructs~HashSet</a></li><li><a href="module-name_resolver-NameResolver.html">name_resolver~NameResolver</a></li><li><a href="module-patterns-Attribute.html">patterns~Attribute</a></li><li><a href="module-patterns-AttributeNameError.html">patterns~AttributeNameError</a></li><li><a href="module-patterns-AttributeValueError.html">patterns~AttributeValueError</a></li><li><a href="module-patterns-AttributeWalker.html">patterns~AttributeWalker</a></li><li><a href="module-patterns-Choice.html">patterns~Choice</a></li><li><a href="module-patterns-ChoiceError.html">patterns~ChoiceError</a></li><li><a href="module-patterns-ChoiceWalker.html">patterns~ChoiceWalker</a></li><li><a href="module-patterns-Define.html">patterns~Define</a></li><li><a href="module-patterns-DefineWalker.html">patterns~DefineWalker</a></li><li><a href="module-patterns-DisallowedElementWalker.html">patterns~DisallowedElementWalker</a></li><li><a href="module-patterns-Element.html">patterns~Element</a></li><li><a href="module-patterns-ElementNameError.html">patterns~ElementNameError</a></li><li><a href="module-patterns-ElementWalker.html">patterns~ElementWalker</a></li><li><a href="module-patterns-Empty.html">patterns~Empty</a></li><li><a href="module-patterns-EmptyWalker.html">patterns~EmptyWalker</a></li><li><a href="module-patterns-EName.html">patterns~EName</a></li><li><a href="module-patterns-Event.html">patterns~Event</a></li><li><a href="module-patterns-Grammar.html">patterns~Grammar</a></li><li><a href="module-patterns-GrammarWalker.html">patterns~GrammarWalker</a></li><li><a href="module-patterns-Group.html">patterns~Group</a></li><li><a href="module-patterns-GroupWalker.html">patterns~GroupWalker</a></li><li><a href="module-patterns-NoSubwalker.html">patterns~NoSubwalker</a></li><li><a href="module-patterns-NotAllowed.html">patterns~NotAllowed</a></li><li><a href="module-patterns-OneOrMore.html">patterns~OneOrMore</a></li><li><a href="module-patterns-OneOrMoreWalker.html">patterns~OneOrMoreWalker</a></li><li><a href="module-patterns-Pattern.html">patterns~Pattern</a></li><li><a href="module-patterns-PatternOnePattern.html">patterns~PatternOnePattern</a></li><li><a href="module-patterns-PatternTwoPatterns.html">patterns~PatternTwoPatterns</a></li><li><a href="module-patterns-Ref.html">patterns~Ref</a></li><li><a href="module-patterns-ReferenceError.html">patterns~ReferenceError</a></li><li><a href="module-patterns-RefWalker.html">patterns~RefWalker</a></li><li><a href="module-patterns-SingleNameError.html">patterns~SingleNameError</a></li><li><a href="module-patterns-SingleSubwalker.html">patterns~SingleSubwalker</a></li><li><a href="module-patterns-Text.html">patterns~Text</a></li><li><a href="module-patterns-TextWalker.html">patterns~TextWalker</a></li><li><a href="module-patterns-ValidationError.html">patterns~ValidationError</a></li><li><a href="module-patterns-Walker.html">patterns~Walker</a></li><li><a href="module-set-Set.html">set~Set</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Thu Dec 12 2013 18:26:48 GMT-0600 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
